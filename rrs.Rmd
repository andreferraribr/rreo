---
title: "anexo_1_BO"
output:
  html_document:
    df_print: paged
  reference_docx: rss_style.docx
  code_folding: hide
  word_document: default
  pdf_document: default
---
```{r echo=FALSE, message=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE)
```


```{r libraries, echo=FALSE}
library(flexdashboard)
library(shiny)
library(tidyverse)
library(readxl)
library(DT)
library(plotly)
library(lubridate)
library(RcppRoll)
```

```{r}
# Sys.setlocale(category = "LC_TIME", locale = "pt_BR")
```



```{r echo=FALSE}
# dados originados a partir de rreo_rgf_uf.Rmd
# rotina criada para extrair RREO e RGF do SICONFI API http://apidatalake.tesouro.gov.br/docs/siconfi

# importar df com os dados e classicar por ordem crescente de UF
saude <- read_excel("saude.xlsx")

saude <- saude %>% mutate (percentual = 100*executado/mínimo, mes = month(date, label = TRUE), ano = year(date))

saude <- saude %>% mutate(cores = if_else(percentual>100,"red","blue"))

```

```{r echo=FALSE}
# orientações interessantes na publicação do Colin Fay, Vincent Guyader, Cervan Girard, Sébastien Rochette
# https://thinkr-open.github.io/building-shiny-apps-workflow/structure.html#a-practical-walk-through

# criar função para plotar os gráficos
# argumento df para dataframe
# argumento corte para linha horizontal dividindo valores considerados bons (azul) e ruins (vermelhos)
plot_df = function(df,corte){
  p <- ggplot(df, aes(x=mes, y=percentual, color = cores)) +
  # geom_jitter exclui a UF selecionada para evitar a apresentação de dois pontos para a mesma UF.
  # Caso contrário teríamos um ponto plotado pelo geom_jitter e outro plotado pelo geom_point
    geom_jitter( data = df %>% filter (ano != max(ano)), aes(text=paste("ANO: ", ano)), width=0.25, alpha=0.5) +
  # plotar o point da UF selecionada
    geom_point(data = df %>% filter (ano == max(ano)), aes(x=mes, y=percentual,text=paste("ANO: ", ano), size = 10))+
  # inherit.aes =FALSE para nao herdar aes do geoms anteriores. Caso contrário a linha teria duas cores
    geom_line(data = df %>% filter (ano == max(ano) ),  inherit.aes =TRUE, aes(x=mes, y=percentual))+
  # plotar linha vermelha tracejada dividindo resultados bons (azul), ruins (vermelho). O argumento "corte" define a altura da linha.
    geom_hline(yintercept=corte, colour = "red", linetype = "dashed") +
  # https://ggplot2.tidyverse.org/reference/geom_smooth.html
  # inherit.aes =FALSE para evitar duas linhas de tendência.
  # Caso contrário teríamos uma linha de tendência para a cada factor level (coluna cores).
  # Uma linha de tendência para os pontos de cor vermelha e outra linha de tendência para os pontos de cor azul  
    geom_smooth( method = "loess", inherit.aes =FALSE,aes(x=mes, y=percentual), color = "gray" )+
    # definir informação dos eixos
    labs( x = "mês",
          y = "%")+ theme_classic()+ 
  # escala de cor. Os levels são definidos na coluna cores da df_limites.
    scale_color_manual(breaks = levels(df$cores),
                        values=c("red", "blue"))
  # optei por esconder a legenda (showlegend = FALSE)
(p <- ggplotly(p))%>% layout(showlegend = FALSE)
}

```

```{r echo=FALSE}

atual <- saude %>% filter(year(date)== max(year(date))) 
ggplot(saude, aes(x=mes, y=percentual, colour = year(date))) +
  geom_jitter()+
  # plotar linha vermelha tracejada dividindo resultados bons (azul), ruins (vermelho). O argumento "corte" define a altura da linha.
    geom_hline(yintercept=1, colour = "blue", linetype = "dashed")+
 
  # adicionar reta de ajuste de um modelo linear
  geom_smooth(method = "lm")



 ggplot(atual, aes(as.Date(date), percentual))+
  geom_line()
   # scale_x_date(month(as.Date(atual$date)))
  
```

```{r}
 library(readr)
anexo_1_ate_o_mes <- read_csv("anexo_1_ate_o_mes.csv", 
    locale = locale(decimal_mark = ","), 
    skip = 5)
View(anexo_1_ate_o_mes)
```
```{r eval=FALSE, include=FALSE}
plot_df(saude,100)
```

```{r}
  p <- ggplot(saude, aes(x=mes, y=percentual, color = cores)) +
  # geom_jitter exclui a UF selecionada para evitar a apresentação de dois pontos para a mesma UF.
  # Caso contrário teríamos um ponto plotado pelo geom_jitter e outro plotado pelo geom_point
    geom_jitter( data = saude %>% filter (ano != max(ano)), aes(text=paste("ANO: ", ano)), width=0.1, alpha=0.25) +
  # plotar o point da UF selecionada
    geom_point(data = saude %>% filter (ano == max(ano)), aes(x=mes, y=percentual,text=paste("ANO: ", ano), size = 10))+
  # inherit.aes =FALSE para nao herdar aes do geoms anteriores. Caso contrário a linha teria duas cores
    geom_line(data = saude %>% filter (ano == max(ano) ),  inherit.aes =TRUE, aes(x=mes, y=percentual))+
  # plotar linha vermelha tracejada dividindo resultados bons (azul), ruins (vermelho). O argumento "corte" define a altura da linha.
    geom_hline(yintercept=100, colour = "red", linetype = "dashed") +
  # https://ggplot2.tidyverse.org/reference/geom_smooth.html
  # inherit.aes =FALSE para evitar duas linhas de tendência.
  # Caso contrário teríamos uma linha de tendência para a cada factor level (coluna cores).
  # Uma linha de tendência para os pontos de cor vermelha e outra linha de tendência para os pontos de cor azul  
    geom_smooth( method = "loess", inherit.aes =FALSE,aes(x=mes, y=percentual), color = "gray" )+
    # definir informação dos eixos
    labs( x = "mês",
          y = "%")+ theme_classic()+ 
  # escala de cor. Os levels são definidos na coluna cores da df_limites.
    scale_color_manual(breaks = levels(saude$cores),
                        values=c("red", "blue"))
  # optei por esconder a legenda (showlegend = FALSE)
# (p <- ggplotly(p))%>% layout(showlegend = FALSE)
```

```{r}
ggplot(saude %>% filter (ano ==2021), aes(y = percentual)) + 
  geom_point(aes(x = mes), colour = "red") + 
  geom_line(aes(x = mes), colour = "red") + 
  geom_line(aes(x = month(as.Date(date))), colour = "blue") 
  # geom_line(aes(x = mes), colour = "blue")
```

```{r}
p <- ggplot(saude, aes(y=percentual, color = cores)) +
  # geom_jitter exclui a UF selecionada para evitar a apresentação de dois pontos para a mesma UF.
  # Caso contrário teríamos um ponto plotado pelo geom_jitter e outro plotado pelo geom_point
    geom_jitter( data = saude %>% filter (ano != max(ano)), aes(x = mes, text=paste("ANO: ", ano)), alpha=0.2) +
  # plotar o point da UF selecionada
    geom_point(data = saude %>% filter (ano == max(ano)), aes(x=mes, y=percentual,text=paste("ANO: ", ano)))+
  
  # plotar linha vermelha tracejada dividindo resultados bons (azul), ruins (vermelho). O argumento "corte" define a altura da linha.
    geom_hline(yintercept=100, colour = "red", linetype = "dashed") +
  # https://ggplot2.tidyverse.org/reference/geom_smooth.html
  # inherit.aes =FALSE para evitar duas linhas de tendência.
  # Caso contrário teríamos uma linha de tendência para a cada factor level (coluna cores).
  # Uma linha de tendência para os pontos de cor vermelha e outra linha de tendência para os pontos de cor azul  
    geom_smooth( method = "loess", inherit.aes =FALSE,aes(x=mes, y=percentual), color = "gray" )+
  # inherit.aes =FALSE para nao herdar aes do geoms anteriores. Caso contrário a linha teria duas cores
    geom_line(data = saude %>% filter (ano == max(ano) ),  inherit.aes =TRUE, aes(x=month(as.Date(date)), y=percentual))+ 
  
   # definir informação dos eixos
    labs( x = "mês",
          y = "%")+ theme_classic()+ 
  # escala de cor. Os levels são definidos na coluna cores da df_limites.
    scale_color_manual(breaks = levels(saude$cores),
                        values=c("red", "blue"))+
  ggtitle("Percentual mínimo de despesa com Saúde")+
  # optei por esconder a legenda (showlegend = FALSE)
geom_text(data = saude %>% filter (date == max(date)), aes(x=mes, y=percentual+2.5, label = ano))
# (p <- ggplotly(p))%>% layout(showlegend = FALSE)
p
```
```{r echo=FALSE}
previ <- read_excel("previ.xlsx")

names(previ)[1] <- "date"

previ <- previ %>% mutate (receita =rowSums( previ[,startsWith(names(previ),"Movimento R")]), despesa  =rowSums( previ[,startsWith(names(previ),"Movimento D")]), resultado = receita - despesa)
datatable(previ)
# https://itsalocke.com/blog/understanding-rolling-calculations-in-r/
previ <- previ %>% mutate(acumulado = roll_sum(resultado,12, fill=NA, align="right")/1000000000)

```

```{r}


ggplot(previ , aes(x = (as.Date(date)),y = resultado)) + 
  geom_line(aes( colour = "blue"))+
   geom_smooth(method = "loess", color = "red") 
  # geom_line(aes(x = mes), colour = "blue")
```
```{r}
# https://itsalocke.com/blog/understanding-rolling-calculations-in-r/
ggplot(previ , aes(x = (as.Date(date)),y = acumulado)) + 
  geom_line(aes( colour = "blue"))
   # geom_smooth(method = "loess", color = "red") 
```



```{r}
rcl <- read_excel("rcl.xlsx")

rcl <- rcl %>% mutate(acumulado = roll_sum(`RECEITA CORRENTE LÍQUIDA (III) = (I - II)`,12, fill=NA, align="right")/1000000)

library(zoo)


ggplot(rcl , aes(x = (as.Date(item)),y = acumulado)) + 
  geom_line(aes( colour = "blue"))

# 
# names(rcl) <- c("item",teste)
# 
# rcl %>% filter(startsWith(item,"RECEITA")) %>% pivot_longer(cols = everything())
```

